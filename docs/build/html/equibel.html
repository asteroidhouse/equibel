

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>equibel package &mdash; Equibel a1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Equibel a1 documentation" href="index.html"/>
        <link rel="up" title="equibel" href="modules.html"/>
        <link rel="next" title="equibel.asp package" href="equibel.asp.html"/>
        <link rel="prev" title="equibel" href="modules.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Equibel
          

          
          </a>

          
            
            
              <div class="version">
                0.9.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="equibelgraphref.html">Working with Graphs and Scenarios</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphgenerators.html">Graph Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">equibel</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">equibel package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="equibel.asp.html">equibel.asp package</a></li>
<li class="toctree-l4"><a class="reference internal" href="equibel.formatters.html">equibel.formatters package</a></li>
<li class="toctree-l4"><a class="reference internal" href="equibel.includes.html">equibel.includes package</a></li>
<li class="toctree-l4"><a class="reference internal" href="equibel.parsers.html">equibel.parsers package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-equibel.asprin">equibel.asprin module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-equibel.draw">equibel.draw module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-equibel.formulagen">equibel.formulagen module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-equibel.graph">equibel.graph module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-equibel.graphgen">equibel.graphgen module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-equibel.solver">equibel.solver module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-equibel">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="licence.html">Licence</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Equibel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="modules.html">equibel</a> &raquo;</li>
      
    <li>equibel package</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/equibel.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="equibel-package">
<h1>equibel package<a class="headerlink" href="#equibel-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="equibel.asp.html">equibel.asp package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="equibel.asp.html#module-equibel.asp">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="equibel.formatters.html">equibel.formatters package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="equibel.formatters.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="equibel.formatters.html#module-equibel.formatters.aspformatter">equibel.formatters.aspformatter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="equibel.formatters.html#equibel-formatters-bcfformatter-module">equibel.formatters.bcfformatter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="equibel.formatters.html#module-equibel.formatters">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="equibel.includes.html">equibel.includes package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="equibel.includes.html#subpackages">Subpackages</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="equibel.includes.html#module-equibel.includes">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="equibel.parsers.html">equibel.parsers package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="equibel.parsers.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="equibel.parsers.html#equibel-parsers-bcfparser-module">equibel.parsers.bcfparser module</a></li>
<li class="toctree-l2"><a class="reference internal" href="equibel.parsers.html#module-equibel.parsers.formulaparser">equibel.parsers.formulaparser module</a></li>
<li class="toctree-l2"><a class="reference internal" href="equibel.parsers.html#module-equibel.parsers.parsetab">equibel.parsers.parsetab module</a></li>
<li class="toctree-l2"><a class="reference internal" href="equibel.parsers.html#module-equibel.parsers">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-equibel.asprin">
<span id="equibel-asprin-module"></span><h2>equibel.asprin module<a class="headerlink" href="#module-equibel.asprin" title="Permalink to this headline">¶</a></h2>
<p>This file provides a programmatic interface to the <code class="docutils literal"><span class="pre">asprin</span></code> preference handling
framework - this allows asprin to be invoked from Python, and allows preferred answer
to be returned directly in Python.
The currently distributed version of <code class="docutils literal"><span class="pre">asprin</span></code> is designed as a stand-alone system,
so using it as-is would involve parsing its command-line output.</p>
<dl class="function">
<dt id="equibel.asprin.cat">
<code class="descclassname">equibel.asprin.</code><code class="descname">cat</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#cat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.cat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.asprin.compute_optimal_models">
<code class="descclassname">equibel.asprin.</code><code class="descname">compute_optimal_models</code><span class="sig-paren">(</span><em>input_files</em>, <em>program_parts_to_add=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#compute_optimal_models"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.compute_optimal_models" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.asprin.doEnumerate">
<code class="descclassname">equibel.asprin.</code><code class="descname">doEnumerate</code><span class="sig-paren">(</span><em>prg</em>, <em>step</em>, <em>maxmodels</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#doEnumerate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.doEnumerate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.asprin.get">
<code class="descclassname">equibel.asprin.</code><code class="descname">get</code><span class="sig-paren">(</span><em>val</em>, <em>default</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.asprin.getHolds">
<code class="descclassname">equibel.asprin.</code><code class="descname">getHolds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#getHolds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.getHolds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.asprin.getNHolds">
<code class="descclassname">equibel.asprin.</code><code class="descname">getNHolds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#getNHolds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.getNHolds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.asprin.handleError">
<code class="descclassname">equibel.asprin.</code><code class="descname">handleError</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#handleError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.handleError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.asprin.onModel">
<code class="descclassname">equibel.asprin.</code><code class="descname">onModel</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#onModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.onModel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.asprin.onModelMany">
<code class="descclassname">equibel.asprin.</code><code class="descname">onModelMany</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#onModelMany"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.onModelMany" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.asprin.printShown">
<code class="descclassname">equibel.asprin.</code><code class="descname">printShown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#printShown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.printShown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.asprin.printShownOpt">
<code class="descclassname">equibel.asprin.</code><code class="descname">printShownOpt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/asprin.html#printShownOpt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.asprin.printShownOpt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-equibel.draw">
<span id="equibel-draw-module"></span><h2>equibel.draw module<a class="headerlink" href="#module-equibel.draw" title="Permalink to this headline">¶</a></h2>
<p>Provides drawing functions that enable visualization of:</p>
<ol class="arabic simple">
<li>Arbitrary graphs and associated scenarios;</li>
<li>Model graphs corresponding to base graphs, for the
restricted case where the base graphs are paths.</li>
</ol>
<p>This file defines functions that extend the graph drawing capabilities
of NetworkX by adding the option to display formulas associated with nodes.</p>
<p>Visualization of model graphs is limited to the case where the
base graph is a path graph; this is not due to technical constraints,
but rather due to the fact that it is difficult to spatially lay
out nodes of arbitrary graphs in such a way that the resulting model
graph is human-readable.</p>
<dl class="function">
<dt id="equibel.draw.allmin">
<code class="descclassname">equibel.draw.</code><code class="descname">allmin</code><span class="sig-paren">(</span><em>lst</em>, <em>less_than=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#allmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.allmin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.draw.copy_dict">
<code class="descclassname">equibel.draw.</code><code class="descname">copy_dict</code><span class="sig-paren">(</span><em>source_dict</em>, <em>diffs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#copy_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.copy_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of source_dict, updated with the new key-value pairs in diffs.</p>
</dd></dl>

<dl class="function">
<dt id="equibel.draw.draw_graph">
<code class="descclassname">equibel.draw.</code><code class="descname">draw_graph</code><span class="sig-paren">(</span><em>G</em>, <em>pos=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#draw_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.draw_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a graph and associated scenario by displaying formulas above each node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> (<a class="reference internal" href="#equibel.graph.EquibelGraph" title="equibel.graph.EquibelGraph"><em>EquibelGraph</em></a>) &#8211; The graph/scenario to draw.</li>
<li><strong>pos</strong> (<em>dict</em>) &#8211; An optional dictionary mapping nodes in G to (x,y) coordinates where they should
be drawn. By default, <code class="docutils literal"><span class="pre">pos</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, and the spatial layout of nodes is
automatically determined by using the NetworkX <code class="docutils literal"><span class="pre">spring_layout</span></code> method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.draw.draw_model_graph">
<code class="descclassname">equibel.draw.</code><code class="descname">draw_model_graph</code><span class="sig-paren">(</span><em>G</em>, <em>pos=None</em>, <em>show_only_min_edges=False</em>, <em>highlight_nodes=[]</em>, <em>highlight_color='#33FF99'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#draw_model_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.draw_model_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.draw.draw_path_model_graph">
<code class="descclassname">equibel.draw.</code><code class="descname">draw_path_model_graph</code><span class="sig-paren">(</span><em>G</em>, <em>R1=None</em>, <em>R2=None</em>, <em>show_only_min_edges=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#draw_path_model_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.draw_path_model_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.draw.find_diff_nodes">
<code class="descclassname">equibel.draw.</code><code class="descname">find_diff_nodes</code><span class="sig-paren">(</span><em>S</em>, <em>T</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#find_diff_nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.find_diff_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of nodes that have different formulas in graphs S and T.</p>
</dd></dl>

<dl class="function">
<dt id="equibel.draw.min_model_edges">
<code class="descclassname">equibel.draw.</code><code class="descname">min_model_edges</code><span class="sig-paren">(</span><em>edge_change_sets</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#min_model_edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.min_model_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.draw.model_set">
<code class="descclassname">equibel.draw.</code><code class="descname">model_set</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#model_set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.model_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a model from a dictionary representation to a set representation.</p>
<p>Given a <code class="docutils literal"><span class="pre">model</span></code> represented by a dictionary mapping atoms to Boolean values,
this function returns the <em>set</em> of atoms that are mapped to <code class="docutils literal"><span class="pre">True</span></code> in the dictionary.</p>
<p>model : A dictionary mapping atoms to Boolean values.</p>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">eb</span><span class="o">.</span><span class="n">parse_formula</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span> <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="s2">&quot;pqr&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">model_set</span><span class="p">({</span><span class="n">p</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">set([p, r])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.draw.models_with_all_atoms">
<code class="descclassname">equibel.draw.</code><code class="descname">models_with_all_atoms</code><span class="sig-paren">(</span><em>formula</em>, <em>atoms</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#models_with_all_atoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.models_with_all_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a formula and a set of atoms (that do not necessarily appear in the formula),
and returns a set of <em>models</em> of the formula, where each model is represented by a
<em>dictionary</em> that maps each atom to a Boolean value, where atoms are drawn from the
set of atoms that appear in <code class="docutils literal"><span class="pre">formula</span></code> <em>and</em> the set of atoms represented by <code class="docutils literal"><span class="pre">atoms</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>formula</strong> (<em>A Sympy formula.</em>) &#8211; </li>
<li><strong>atoms</strong> (<em>A set of Sympy atoms.</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">eb</span><span class="o">.</span><span class="n">parse_formula</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span> <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="s2">&quot;pqr&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">p</span> <span class="o">|</span> <span class="n">q</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">models_with_all_atoms</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">{</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">})</span>
<span class="go">[{p: True, q: True},</span>
<span class="go"> {p: True, q: False},</span>
<span class="go"> {p: False, q: True}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">models_with_all_atoms</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">{</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">})</span>
<span class="go">[{p: True, q: True, r: True},</span>
<span class="go"> {p: True, q: True, r: False},</span>
<span class="go"> {p: True, q: False, r: True},</span>
<span class="go"> {p: True, q: False, r: False},</span>
<span class="go"> {p: False, q: True, r: True},</span>
<span class="go"> {p: False, q: True, r: False}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.draw.symmetric_diff">
<code class="descclassname">equibel.draw.</code><code class="descname">symmetric_diff</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#symmetric_diff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.symmetric_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the symmetric difference of sets <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="equibel.draw.tablize">
<code class="descclassname">equibel.draw.</code><code class="descname">tablize</code><span class="sig-paren">(</span><em>atoms</em>, <em>truths={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/draw.html#tablize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.draw.tablize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-equibel.formulagen">
<span id="equibel-formulagen-module"></span><h2>equibel.formulagen module<a class="headerlink" href="#module-equibel.formulagen" title="Permalink to this headline">¶</a></h2>
<p>This file contains functions to generate random propositional formulas.</p>
<dl class="function">
<dt id="equibel.formulagen.random_formula">
<code class="descclassname">equibel.formulagen.</code><code class="descname">random_formula</code><span class="sig-paren">(</span><em>num_atoms=3</em>, <em>num_connectives=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/formulagen.html#random_formula"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.formulagen.random_formula" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.formulagen.random_formula_simplified">
<code class="descclassname">equibel.formulagen.</code><code class="descname">random_formula_simplified</code><span class="sig-paren">(</span><em>num_atoms=3</em>, <em>num_connectives=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/formulagen.html#random_formula_simplified"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.formulagen.random_formula_simplified" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.formulagen.simplify">
<code class="descclassname">equibel.formulagen.</code><code class="descname">simplify</code><span class="sig-paren">(</span><em>formula</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/formulagen.html#simplify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.formulagen.simplify" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-equibel.graph">
<span id="equibel-graph-module"></span><h2>equibel.graph module<a class="headerlink" href="#module-equibel.graph" title="Permalink to this headline">¶</a></h2>
<p>The EquibelGraph class represents a graph $G$ together with an associated
$G$-scenario $sigma$. It extends the NetworkX <code class="docutils literal"><span class="pre">Graph</span></code> class and adds the
ability to associate propositional formulas with nodes. Such formulas are
represented using Sympy formula objects, from the <code class="docutils literal"><span class="pre">logic</span></code> module of the
Sympy package for symbolic mathematics.</p>
<dl class="class">
<dt id="equibel.graph.EquibelGraph">
<em class="property">class </em><code class="descclassname">equibel.graph.</code><code class="descname">EquibelGraph</code><span class="sig-paren">(</span><em>data=None</em>, <em>**attr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graph.html#EquibelGraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graph.EquibelGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">networkx.classes.graph.Graph</span></code></p>
<dl class="method">
<dt id="equibel.graph.EquibelGraph.add_formula">
<code class="descname">add_formula</code><span class="sig-paren">(</span><em>node_id</em>, <em>formula</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graph.html#EquibelGraph.add_formula"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graph.EquibelGraph.add_formula" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a formula to the set of formulas associated with a node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node_id</strong> (<em>The identifier of the desired node (usually an int)</em>) &#8211; </li>
<li><strong>formula</strong> (This can be either a <em>Sympy formula object</em>, or a <em>string</em>) &#8211; representing a formula in infix notation</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">EquibelGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a Sympy formula object and associate it with node 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">form</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">parse_formula</span><span class="p">(</span><span class="s1">&#39;p &amp; q&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">form</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">formulas</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">set([And(p, q)])</span>
</pre></div>
</div>
<p>Add a formula using a formula string expressed in infix notation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;q | ~r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">formulas</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">set([Or(Not(r), q), And(p, q)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="equibel.graph.EquibelGraph.atoms">
<code class="descname">atoms</code><span class="sig-paren">(</span><em>node_id=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graph.html#EquibelGraph.atoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graph.EquibelGraph.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns either the set of atoms used by a specific node in the graph, or
the set of all atoms used by <em>any</em> node in the graph.</p>
<p>If <code class="docutils literal"><span class="pre">node_id</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>, then this function returns the set of
atoms used by the formula at <code class="docutils literal"><span class="pre">node_id</span></code>; if <code class="docutils literal"><span class="pre">node_id</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, then
this function returns the set of all atoms used by formulas of <em>any</em> node
in the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node_id</strong> (<em>The identifier of the desired node (usually an int)</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;p -&gt; q&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;q | ~r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">set([p, q])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">set([r, q])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">set([p, r, q])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="equibel.graph.EquibelGraph.clear_formulas">
<code class="descname">clear_formulas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graph.html#EquibelGraph.clear_formulas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graph.EquibelGraph.clear_formulas" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all formulas from all nodes in the graph.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;p | (q &amp; r)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;~p&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;q | r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">formulas</span><span class="p">()</span>
<span class="go">{1: set([Or(And(q, r), p)]), 2: set([Not(p)]), 3: set([Or(q, r)])}</span>
</pre></div>
</div>
<p>Now clear all formulas:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">clear_formulas</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">formulas</span><span class="p">()</span>
<span class="go">{0: set([]), 1: set([]), 2: set([]), 3: set([])}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="equibel.graph.EquibelGraph.clear_formulas_from">
<code class="descname">clear_formulas_from</code><span class="sig-paren">(</span><em>node_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graph.html#EquibelGraph.clear_formulas_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graph.EquibelGraph.clear_formulas_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all formulas from a node. Thus, resets a node to a blank slate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node_id</strong> (<em>The identifier of the desired node (usually an int)</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">EquibelGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;p &amp; q | r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">formulas</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">set([Or(And(p, q), r)])</span>
</pre></div>
</div>
<p>Clear the formulas from node 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">clear_formulas_from</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">formulas</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">set([])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="equibel.graph.EquibelGraph.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graph.html#EquibelGraph.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graph.EquibelGraph.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a deep copy of this graph.</p>
<p class="rubric">Examples</p>
<p>Create a graph:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a copy of the graph:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p>The copy is independently modifiable:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1), (1, 2), (2, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1), (1, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="equibel.graph.EquibelGraph.formula_conj">
<code class="descname">formula_conj</code><span class="sig-paren">(</span><em>node_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graph.html#EquibelGraph.formula_conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graph.EquibelGraph.formula_conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the conjunction of all formulas associated with a given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node_id</strong> (<em>The identifier of the desired node (usually an int)</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">EquibelGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;p &amp; q&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;r -&gt; s&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">formula_conj</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">And(Implies(r, s), p, q)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="equibel.graph.EquibelGraph.formulas">
<code class="descname">formulas</code><span class="sig-paren">(</span><em>node_id=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graph.html#EquibelGraph.formulas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graph.EquibelGraph.formulas" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of formulas associated with <code class="docutils literal"><span class="pre">node_id</span></code>, or,
if <code class="docutils literal"><span class="pre">node_id</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, returns a dictionary of
(<code class="docutils literal"><span class="pre">node_id</span></code>, <code class="docutils literal"><span class="pre">formula_set</span></code>) mappings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node_id</strong> (<em>The identifier of the desired node (usually an integer)</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;p &amp; q&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;p | ~r&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the formulas at a specific node:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">formulas</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">set([And(p, q)])</span>
</pre></div>
</div>
<p>Get a dictionary showing the formulas at every node:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">formulas</span><span class="p">()</span>
<span class="go">{0: set([And(p, q)]), 1: set([Or(Not(r), p)]), 2: set([]), 3: set([])}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="equibel.graph.EquibelGraph.to_asp">
<code class="descname">to_asp</code><span class="sig-paren">(</span><em>atoms=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graph.html#EquibelGraph.to_asp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graph.EquibelGraph.to_asp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ASP encoding of this EquibelGraph object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>atoms</strong> (<em>An iterable container of Sympy atoms</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;p &amp; q&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;~q | r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;p -&gt; ~r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">to_asp</span><span class="p">())</span>
<span class="go">node(0).</span>
<span class="go">node(1).</span>
<span class="go">node(2).</span>
<span class="go">edge(0,1).</span>
<span class="go">edge(1,0).</span>
<span class="go">edge(0,2).</span>
<span class="go">edge(2,0).</span>
<span class="go">edge(1,2).</span>
<span class="go">edge(2,1).</span>
<span class="go">formula(0,and(p,q)).</span>
<span class="go">formula(1,or(r,neg(q))).</span>
<span class="go">formula(2,implies(p,neg(r))).</span>
<span class="go">atom(p).</span>
<span class="go">atom(r).</span>
<span class="go">atom(q).</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="equibel.graph.EquibelGraphException">
<em class="property">exception </em><code class="descclassname">equibel.graph.</code><code class="descname">EquibelGraphException</code><a class="reference internal" href="_modules/equibel/graph.html#EquibelGraphException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graph.EquibelGraphException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
</dd></dl>

</div>
<div class="section" id="module-equibel.graphgen">
<span id="equibel-graphgen-module"></span><h2>equibel.graphgen module<a class="headerlink" href="#module-equibel.graphgen" title="Permalink to this headline">¶</a></h2>
<p>Equibel wrappers for NetworkX graph generator functions.</p>
<p>This file contains wrapper functions for several networkx graph
generators. The wrappers return EquibelGraph objects that contain
the corresponding NetworkX graphs.</p>
<dl class="function">
<dt id="equibel.graphgen.complete_graph">
<code class="descclassname">equibel.graphgen.</code><code class="descname">complete_graph</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graphgen.html#complete_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graphgen.complete_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an undirected complete graph on n nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>The desired number of nodes for the complete graph.</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>G</strong></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">An <code class="docutils literal"><span class="pre">EquibelGraph</span></code> containing a complete graph on <code class="docutils literal"><span class="pre">n</span></code> nodes.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.graphgen.connected_watts_strogatz_graph">
<code class="descclassname">equibel.graphgen.</code><code class="descname">connected_watts_strogatz_graph</code><span class="sig-paren">(</span><em>n=10</em>, <em>k=4</em>, <em>p=0.5</em>, <em>tries=100</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graphgen.html#connected_watts_strogatz_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graphgen.connected_watts_strogatz_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.graphgen.erdos_renyi_graph">
<code class="descclassname">equibel.graphgen.</code><code class="descname">erdos_renyi_graph</code><span class="sig-paren">(</span><em>n</em>, <em>p</em>, <em>seed=None</em>, <em>directed=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graphgen.html#erdos_renyi_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graphgen.erdos_renyi_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.graphgen.gnm_random_graph">
<code class="descclassname">equibel.graphgen.</code><code class="descname">gnm_random_graph</code><span class="sig-paren">(</span><em>n</em>, <em>m</em>, <em>seed=None</em>, <em>directed=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graphgen.html#gnm_random_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graphgen.gnm_random_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.graphgen.path_graph">
<code class="descclassname">equibel.graphgen.</code><code class="descname">path_graph</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graphgen.html#path_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graphgen.path_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an undirected line graph on n nodes, numbered using
the integers 0 to n-1, inclusive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>The desired number of nodes for the line graph.</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>G</strong></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">An <code class="docutils literal"><span class="pre">EquibelGraph</span></code> representing a path graph on <code class="docutils literal"><span class="pre">n</span></code> nodes.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create an undirected path graph 0 &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; 3:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.graphgen.petersen_graph">
<code class="descclassname">equibel.graphgen.</code><code class="descname">petersen_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graphgen.html#petersen_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graphgen.petersen_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.graphgen.star_graph">
<code class="descclassname">equibel.graphgen.</code><code class="descname">star_graph</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graphgen.html#star_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graphgen.star_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an undirected star graph on n+1 nodes, with one
central node, and n outer nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>The desired number of outer nodes for the star graph.</em>) &#8211; The generated graph will have a central node numbered
<code class="docutils literal"><span class="pre">0</span></code>, and <code class="docutils literal"><span class="pre">n</span></code> outer nodes numbered from <code class="docutils literal"><span class="pre">1</span></code> to <code class="docutils literal"><span class="pre">n</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>G</strong></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">An <code class="docutils literal"><span class="pre">EquibelGraph</span></code> containing a star graph on <code class="docutils literal"><span class="pre">n+1</span></code> nodes.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">star_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.graphgen.waxman_graph">
<code class="descclassname">equibel.graphgen.</code><code class="descname">waxman_graph</code><span class="sig-paren">(</span><em>n</em>, <em>alpha=0.4</em>, <em>beta=0.1</em>, <em>L=None</em>, <em>domain=(0</em>, <em>0</em>, <em>1</em>, <em>1)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/graphgen.html#waxman_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.graphgen.waxman_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-equibel.solver">
<span id="equibel-solver-module"></span><h2>equibel.solver module<a class="headerlink" href="#module-equibel.solver" title="Permalink to this headline">¶</a></h2>
<p>This file contains functions that implement the following approaches
to consistency-based belief change in a graph-oriented setting:</p>
<ol class="arabic simple">
<li>Global completion: <code class="docutils literal"><span class="pre">eb.global_completion(G)</span></code></li>
<li>Simple iteration: <code class="docutils literal"><span class="pre">eb.iterate_simple(G)</span></code></li>
<li>Expanding iteration: <code class="docutils literal"><span class="pre">eb.iterate_expanding(G)</span></code></li>
<li>Augmenting iteration: <code class="docutils literal"><span class="pre">eb.iterate_augmenting(G)</span></code></li>
<li>The ring method: <code class="docutils literal"><span class="pre">eb.iterate_ring(G)</span></code></li>
</ol>
<p>Each of the approaches has two separate implementations, corresponding to
the <em>semantic</em> and <em>syntactic</em> characterizations. In addition, there are
two ways of maximizing equivalences used by any approach: <em>inclusion-based</em>
or <em>cardinality-based</em> maximization.</p>
<dl class="docutils">
<dt>Each function listed above takes three optional arguments:</dt>
<dd><ol class="first last arabic simple">
<li><code class="docutils literal"><span class="pre">method</span></code>, which is a string that is either &#8220;semantic&#8221; or &#8220;syntactic&#8221;,
representing the method by which to perform the completion; e.g. based
on either the syntactic or semantic characterizations</li>
<li><code class="docutils literal"><span class="pre">opt_type</span></code>, which is a string that is either &#8220;inclusion&#8221; or &#8220;cardinality&#8221;,
representing the type of maximization to be  performed over equivalences</li>
<li><code class="docutils literal"><span class="pre">simplify</span></code>, which is a Boolean flag specifying whether to simplify the
final formulas at each node.</li>
</ol>
</dd>
</dl>
<dl class="function">
<dt id="equibel.solver.augmenting_iteration_maximal_answer_sets">
<code class="descclassname">equibel.solver.</code><code class="descname">augmenting_iteration_maximal_answer_sets</code><span class="sig-paren">(</span><em>G</em>, <em>distances</em>, <em>center</em>, <em>eccentricity</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#augmenting_iteration_maximal_answer_sets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.augmenting_iteration_maximal_answer_sets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.augmenting_semantic">
<code class="descclassname">equibel.solver.</code><code class="descname">augmenting_semantic</code><span class="sig-paren">(</span><em>G</em>, <em>center</em>, <em>atoms</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#augmenting_semantic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.augmenting_semantic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.augmenting_syntactic">
<code class="descclassname">equibel.solver.</code><code class="descname">augmenting_syntactic</code><span class="sig-paren">(</span><em>G</em>, <em>center</em>, <em>atoms</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#augmenting_syntactic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.augmenting_syntactic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.conjunction">
<code class="descclassname">equibel.solver.</code><code class="descname">conjunction</code><span class="sig-paren">(</span><em>formulas</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#conjunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.conjunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the conjunction of a set of propositional formulas.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>formulas</strong> (<em>an iterable container of Sympy formulas</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">formulas</span> <span class="o">=</span> <span class="p">[</span><span class="n">eb</span><span class="o">.</span><span class="n">parse_formula</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="s2">&quot;pqrst&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">formulas</span>
<span class="go">[p, q, r, s, t]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">conjunction</span><span class="p">(</span><span class="n">formulas</span><span class="p">)</span>
<span class="go">And(p, q, r, s, t)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.create_distance_string">
<code class="descclassname">equibel.solver.</code><code class="descname">create_distance_string</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#create_distance_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.create_distance_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a string containing the ASP encoding of the shortest-path
distances between all pairs of nodes in <code class="docutils literal"><span class="pre">G</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>G</strong> (<em>An EquibelGraph object.</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>dist_str</strong> &#8211; represents that the distance between nodes <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> is <code class="docutils literal"><span class="pre">d</span></code>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">A string containing <code class="docutils literal"><span class="pre">dist/3</span></code> predicates, where <code class="docutils literal"><span class="pre">dist(x,y,d)</span></code></td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eb</span><span class="o">.</span><span class="n">create_distance_string</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="go">dist(0,0,0).</span>
<span class="go">dist(0,1,1).</span>
<span class="go">dist(0,2,2).</span>
<span class="go">dist(1,0,1).</span>
<span class="go">dist(1,1,0).</span>
<span class="go">dist(1,2,1).</span>
<span class="go">dist(2,0,2).</span>
<span class="go">dist(2,1,1).</span>
<span class="go">dist(2,2,0).</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.create_eq_dicts">
<code class="descclassname">equibel.solver.</code><code class="descname">create_eq_dicts</code><span class="sig-paren">(</span><em>answer_sets</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#create_eq_dicts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.create_eq_dicts" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts <code class="docutils literal"><span class="pre">eq/3</span></code> predicates from a set of answer sets, and structures them into a
dictionary that makes it easy to retrieve the set of atoms on which two nodes agree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>answer_sets</strong> (<em>An iterable container of answer sets.</em>) &#8211; Each answer set is represented as a list of <em>terms</em> (defined in the
<code class="docutils literal"><span class="pre">gringo</span></code> module).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.disjunction">
<code class="descclassname">equibel.solver.</code><code class="descname">disjunction</code><span class="sig-paren">(</span><em>formulas</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#disjunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.disjunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the disjunction of a set of propositional formulas.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>formulas</strong> (<em>An iterable container of Sympy formulas</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">formulas</span> <span class="o">=</span> <span class="p">[</span><span class="n">eb</span><span class="o">.</span><span class="n">parse_formula</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="s2">&quot;pqrst&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">formulas</span>
<span class="go">[p, q, r, s, t]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">disjunction</span><span class="p">(</span><span class="n">formulas</span><span class="p">)</span>
<span class="go">Or(p, q, r, s, t)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.expanding_maximal_answer_sets">
<code class="descclassname">equibel.solver.</code><code class="descname">expanding_maximal_answer_sets</code><span class="sig-paren">(</span><em>G</em>, <em>distances</em>, <em>center</em>, <em>radius</em>, <em>atoms=None</em>, <em>neighborhood_type='/Users/paulvicol/Code/Python/equibel_to_update/equibel/asp/neighborhoods/uspt.lp'</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#expanding_maximal_answer_sets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.expanding_maximal_answer_sets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.expanding_semantic">
<code class="descclassname">equibel.solver.</code><code class="descname">expanding_semantic</code><span class="sig-paren">(</span><em>G</em>, <em>center</em>, <em>atoms</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#expanding_semantic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.expanding_semantic" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the formula for node <code class="docutils literal"><span class="pre">center</span></code> in graph <code class="docutils literal"><span class="pre">G</span></code> that results from
one iteration of the expanding approach, using the <em>semantic characterization</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> (An <code class="docutils literal"><span class="pre">EquibelGraph</span></code> object, representing a graph and an associated scenario) &#8211; </li>
<li><strong>center</strong> (A node in <code class="docutils literal"><span class="pre">G</span></code> for which to compute the result of simple iteration) &#8211; </li>
<li><strong>atoms</strong> (A set of Sympy atomic propositions, representing the <em>alphabet</em>.) &#8211; </li>
<li><strong>opt_type</strong> (<em>A string that is either &quot;inclusion&quot; or &quot;cardinality&quot;, representing</em>) &#8211; the type of maximization to be performed over equivalences.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.expanding_syntactic">
<code class="descclassname">equibel.solver.</code><code class="descname">expanding_syntactic</code><span class="sig-paren">(</span><em>G</em>, <em>center</em>, <em>atoms</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#expanding_syntactic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.expanding_syntactic" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the formula for node <code class="docutils literal"><span class="pre">center</span></code> in graph <code class="docutils literal"><span class="pre">G</span></code> that results from
one iteration of the expanding approach, using the <em>syntactic characterization</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> (An <code class="docutils literal"><span class="pre">EquibelGraph</span></code> object, representing a graph and an associated scenario) &#8211; </li>
<li><strong>center</strong> (A node in <code class="docutils literal"><span class="pre">G</span></code> for which to compute the result of simple iteration) &#8211; </li>
<li><strong>atoms</strong> (A set of Sympy atomic propositions, representing the <em>alphabet</em>.) &#8211; </li>
<li><strong>opt_type</strong> (<em>A string that is either &quot;inclusion&quot; or &quot;cardinality&quot;, representing</em>) &#8211; the type of maximization to be performed over equivalences.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.formula_from_eq_sets">
<code class="descclassname">equibel.solver.</code><code class="descname">formula_from_eq_sets</code><span class="sig-paren">(</span><em>G</em>, <em>current_node</em>, <em>eq_sets</em>, <em>atoms</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#formula_from_eq_sets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.formula_from_eq_sets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.formula_from_models">
<code class="descclassname">equibel.solver.</code><code class="descname">formula_from_models</code><span class="sig-paren">(</span><em>models</em>, <em>alphabet</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#formula_from_models"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.formula_from_models" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a formula in disjunctive normal form (DNF) given a set of models
and an alphabet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>models</strong> (An iterable container (set, list, etc.) of <em>sets of atoms</em>, where) &#8211; an atom is represented by a Sympy symbol</li>
<li><strong>alphabet</strong> (<em>An iterable container of atoms, represented by Sympy symbols</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">eb</span><span class="o">.</span><span class="n">parse_formula</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="s2">&quot;pqrs&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">models</span> <span class="o">=</span> <span class="p">[{</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">formula_from_models</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">alphabet</span><span class="p">)</span>
<span class="go">And(Not(r), Not(s), p, q)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">models</span> <span class="o">=</span> <span class="p">[{</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">},</span> <span class="p">{</span><span class="n">p</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">formula_from_models</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">alphabet</span><span class="p">)</span>
<span class="go">Or(And(Not(q), Not(r), Not(s), p), And(Not(r), Not(s), p, q))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.global_completion">
<code class="descclassname">equibel.solver.</code><code class="descname">global_completion</code><span class="sig-paren">(</span><em>G</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#global_completion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.global_completion" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the global completion of a graph and associated scenario.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>G</strong> (<em>An EquibelGraph object, representing a graph and associated scenario</em>) &#8211; </li>
<li><strong>method</strong> (<em>A string that is either &quot;semantic&quot; or &quot;syntactic&quot;, representing the</em>) &#8211; method by which to perform the completion; e.g. based on either the
syntactic or semantic characterizations.</li>
<li><strong>opt_type</strong> (<em>A string that is either &quot;inclusion&quot; or &quot;cardinality&quot;,</em>) &#8211; representing the type of maximization to be performed
over equivalences.</li>
<li><strong>simplify</strong> (<em>A Boolean flag specifying whether to simplify the final formulas at each node.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">A new EquibelGraph object, representing the global completion of <code class="docutils literal"><span class="pre">G</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.global_completion_semantic">
<code class="descclassname">equibel.solver.</code><code class="descname">global_completion_semantic</code><span class="sig-paren">(</span><em>G</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#global_completion_semantic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.global_completion_semantic" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the global completion of a graph and associated scenario, using the
<strong>semantic characterization</strong>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>G</strong> (<em>An EquibelGraph object, representing a graph and associated scenario</em>) &#8211; </li>
<li><strong>opt_type</strong> (<em>A string that is either &quot;inclusion&quot; or &quot;cardinality&quot;, representing</em>) &#8211; the type of maximization to be performed over equivalences.</li>
<li><strong>simplify</strong> (<em>A Boolean flag specifying whether to simplify the final formulas at each node.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">A new EquibelGraph object, representing the global completion of <code class="docutils literal"><span class="pre">G</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.global_completion_syntactic">
<code class="descclassname">equibel.solver.</code><code class="descname">global_completion_syntactic</code><span class="sig-paren">(</span><em>G</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#global_completion_syntactic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.global_completion_syntactic" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the global completion of a graph and associated scenario, using the
<strong>syntactic characterization</strong>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>G</strong> (<em>An EquibelGraph object, representing a graph and associated scenario</em>) &#8211; </li>
<li><strong>opt_type</strong> (<em>A string that is either &quot;inclusion&quot; or &quot;cardinality&quot;, representing</em>) &#8211; the type of maximization to be performed over equivalences.</li>
<li><strong>simplify</strong> (<em>A Boolean flag specifying whether to simplify the final formulas at each node.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">A new EquibelGraph object, representing the global completion of <code class="docutils literal"><span class="pre">G</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.iterate_augmenting">
<code class="descclassname">equibel.solver.</code><code class="descname">iterate_augmenting</code><span class="sig-paren">(</span><em>G</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#iterate_augmenting"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.iterate_augmenting" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.iterate_augmenting_fixpoint">
<code class="descclassname">equibel.solver.</code><code class="descname">iterate_augmenting_fixpoint</code><span class="sig-paren">(</span><em>G</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#iterate_augmenting_fixpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.iterate_augmenting_fixpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the fixpoint of <em>augmenting iteration</em> with respect the graph <code class="docutils literal"><span class="pre">G</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.iterate_expanding">
<code class="descclassname">equibel.solver.</code><code class="descname">iterate_expanding</code><span class="sig-paren">(</span><em>G</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#iterate_expanding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.iterate_expanding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.iterate_expanding_fixpoint">
<code class="descclassname">equibel.solver.</code><code class="descname">iterate_expanding_fixpoint</code><span class="sig-paren">(</span><em>G</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#iterate_expanding_fixpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.iterate_expanding_fixpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the fixpoint of <em>expanding iteration</em> with respect the graph <code class="docutils literal"><span class="pre">G</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.iterate_function_fixpoint">
<code class="descclassname">equibel.solver.</code><code class="descname">iterate_function_fixpoint</code><span class="sig-paren">(</span><em>G</em>, <em>iteration_function</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#iterate_function_fixpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.iterate_function_fixpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the fixpoint of <code class="docutils literal"><span class="pre">iteration_function</span></code> applied on the graph <code class="docutils literal"><span class="pre">G</span></code>.</p>
<p>This is a higher-order function that repeatedly applies a <em>function</em> <code class="docutils literal"><span class="pre">iteration_function</span></code>,
starting with the initial graph <code class="docutils literal"><span class="pre">G</span></code>, producing a sequence of <code class="docutils literal"><span class="pre">EquibelGraph</span></code> objects,
until reaching a state where the current <code class="docutils literal"><span class="pre">EquibelGraph</span></code> is equal to the previous one; then,
the final <code class="docutils literal"><span class="pre">EquibelGraph</span></code> is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> (An <code class="docutils literal"><span class="pre">EquibelGraph</span></code> object) &#8211; </li>
<li><strong>iteration_function</strong> (The function to be applied iteratively, starting with <code class="docutils literal"><span class="pre">G</span></code>) &#8211; </li>
<li><strong>method</strong> (<em>A string that is either &quot;semantic&quot; or &quot;syntactic&quot;, representing the</em>) &#8211; method by which to perform the completion; e.g. based on either the
syntactic or semantic characterizations.</li>
<li><strong>opt_type</strong> (<em>A string that is either &quot;inclusion&quot; or &quot;cardinality&quot;,</em>) &#8211; representing the type of maximization to be performed
over equivalences.</li>
<li><strong>simplify</strong> (<em>A Boolean flag specifying whether to simplify the final formulas at each node.</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.iterate_ring">
<code class="descclassname">equibel.solver.</code><code class="descname">iterate_ring</code><span class="sig-paren">(</span><em>G</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#iterate_ring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.iterate_ring" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.iterate_ring_fixpoint">
<code class="descclassname">equibel.solver.</code><code class="descname">iterate_ring_fixpoint</code><span class="sig-paren">(</span><em>G</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#iterate_ring_fixpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.iterate_ring_fixpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the fixpoint of the <em>ring method</em> with respect to the graph <code class="docutils literal"><span class="pre">G</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.iterate_simple">
<code class="descclassname">equibel.solver.</code><code class="descname">iterate_simple</code><span class="sig-paren">(</span><em>G</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#iterate_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.iterate_simple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.iterate_simple_fixpoint">
<code class="descclassname">equibel.solver.</code><code class="descname">iterate_simple_fixpoint</code><span class="sig-paren">(</span><em>G</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#iterate_simple_fixpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.iterate_simple_fixpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the fixpoint of <em>simple iteration</em> with respect the graph <code class="docutils literal"><span class="pre">G</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.maximal_answer_sets">
<code class="descclassname">equibel.solver.</code><code class="descname">maximal_answer_sets</code><span class="sig-paren">(</span><em>G</em>, <em>method='semantic'</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#maximal_answer_sets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.maximal_answer_sets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.merge_dicts">
<code class="descclassname">equibel.solver.</code><code class="descname">merge_dicts</code><span class="sig-paren">(</span><em>dictionaries</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#merge_dicts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.merge_dicts" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges multiple separate dictionaries into a single dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dictionaries</strong> (<em>An iterable container of Python dictionaries.</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>merged</strong> &#8211; dicts in <code class="docutils literal"><span class="pre">dictionaries</span></code>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">A single dictionary that represents the result of merging the all the</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>The primary purpose of this function is to create a single dictionary
by combining multiple singleton dictionaries, as shown in the following example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dicts</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">dicts</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 1, &#39;c&#39;: 3, &#39;b&#39;: 2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.only_one_model_for_each_eq_set">
<code class="descclassname">equibel.solver.</code><code class="descname">only_one_model_for_each_eq_set</code><span class="sig-paren">(</span><em>models_for_eq_set_dict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#only_one_model_for_each_eq_set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.only_one_model_for_each_eq_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether each EQ set in <code class="docutils literal"><span class="pre">models_for_eq_set_dict</span></code> is associated with
<em>only one</em> model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>models_for_eq_set_dict</strong> (A dictionary where <em>keys</em> are EQ sets (represented by any) &#8211; hashable objects, in this case strings) and <em>values</em> are
sets of models (where each model is a set of atoms).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><em>Returns True if each EQ set in the dictionary is associated with a single model;</em></li>
<li><em>returns False otherwise (that is, if any EQ set in the dictionary is associated</em></li>
<li><em>with *more than</em> one model).*</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.parallel_iteration">
<code class="descclassname">equibel.solver.</code><code class="descname">parallel_iteration</code><span class="sig-paren">(</span><em>G</em>, <em>iteration_function</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#parallel_iteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.parallel_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies <code class="docutils literal"><span class="pre">iteration_function</span></code> over all nodes in <code class="docutils literal"><span class="pre">G</span></code> <em>in parallel</em> (using process pools).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> (<em>An EquibelGraph object</em>) &#8211; </li>
<li><strong>iteration_function</strong> (<em>A function that conforms to the following input/output interface:</em>) &#8211; <dl class="docutils">
<dt><strong>Input:</strong> Takes a graph <code class="docutils literal"><span class="pre">G</span></code>, a node <code class="docutils literal"><span class="pre">center</span></code> for which to compute</dt>
<dd>the results of the iteration, and a set of <code class="docutils literal"><span class="pre">atoms</span></code>.</dd>
<dt><strong>Output:</strong> Returns a singleton dictionary of the form <code class="docutils literal"><span class="pre">{</span> <span class="pre">center:</span> <span class="pre">formula</span> <span class="pre">}</span></code></dt>
<dd>mapping the node <code class="docutils literal"><span class="pre">center</span></code> to a formula resulting from the iteration.</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.print_formulas">
<code class="descclassname">equibel.solver.</code><code class="descname">print_formulas</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#print_formulas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.print_formulas" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty-prints the formulas associated with nodes in <code class="docutils literal"><span class="pre">G</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>G</strong> (An <code class="docutils literal"><span class="pre">EquibelGraph</span></code> object) &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.revise">
<code class="descclassname">equibel.solver.</code><code class="descname">revise</code><span class="sig-paren">(</span><em>K</em>, <em>alpha</em>, <em>simplify=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#revise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.revise" title="Permalink to this definition">¶</a></dt>
<dd><p>Revises a knowledge base $K$ by a formula $lpha$.</p>
<dl class="docutils">
<dt>This function implements the consistency-based revision operator introduced in [?], by:</dt>
<dd><ol class="first last arabic simple">
<li>Constructing a two-node path graph 0 &lt;&#8211;&gt; 1;</li>
<li>Associating the formulas in $K$ with node 0, and the formula $lpha$ with node 1;</li>
<li>Computing the new belief at node 1 by determining what parts of $K$ can be incorporated
while maintaining consistency with $lpha$.</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>K</strong> (<em>A formula string or a list of formula strings (taken conjunctively as a knowledge base)</em>) &#8211; </li>
<li><strong>alpha</strong> (<em>A formula string or a list of formula strings (taken conjunctively)</em>) &#8211; </li>
<li><strong>simplify</strong> (<em>A Boolean flag specifying whether to simplify the result of revision.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> &#8211; conjunctively.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">A single formula representing the resultant knowledge base $K dot{+} lpha$, taken</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>The simplest way to call this function is to provide a single formula for each of <code class="docutils literal"><span class="pre">K</span></code>
and <code class="docutils literal"><span class="pre">alpha</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">revise</span><span class="p">(</span><span class="s1">&#39;p &amp; q&#39;</span><span class="p">,</span> <span class="s1">&#39;~p | ~q&#39;</span><span class="p">)</span>
<span class="go">And(Or(And(Not(p), q), And(Not(q), p)), Or(Not(p), Not(q)))</span>
</pre></div>
</div>
<p>To pretty-print formulas in infix notation with Unicode symbols, we can use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">eb</span><span class="o">.</span><span class="n">revise</span><span class="p">(</span><span class="s1">&#39;p &amp; q&#39;</span><span class="p">,</span> <span class="s1">&#39;~p | ~q&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that, by default, the formula representing the result of revision is not simplified.
Setting the optional argument <code class="docutils literal"><span class="pre">simplify=True</span></code> enables this final simplification step:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">revise</span><span class="p">(</span><span class="s1">&#39;p &amp; q&#39;</span><span class="p">,</span> <span class="s1">&#39;~p | ~q&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Or(And(Not(p), q), And(Not(q), p))</span>
</pre></div>
</div>
<p>The above revision is equivalent to the following form, using a list of formula strings
[&#8216;p&#8217;, &#8216;q&#8217;] (taken conjunctively) instead of the single formula string &#8216;p &amp; q&#8217;:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">revise</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">],</span> <span class="s1">&#39;~p | ~q&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Or(And(Not(p), q), And(Not(q), p))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.ring_semantic">
<code class="descclassname">equibel.solver.</code><code class="descname">ring_semantic</code><span class="sig-paren">(</span><em>G</em>, <em>center</em>, <em>atoms</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#ring_semantic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.ring_semantic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.ring_syntactic">
<code class="descclassname">equibel.solver.</code><code class="descname">ring_syntactic</code><span class="sig-paren">(</span><em>G</em>, <em>center</em>, <em>atoms</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#ring_syntactic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.ring_syntactic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="equibel.solver.serial_iteration">
<code class="descclassname">equibel.solver.</code><code class="descname">serial_iteration</code><span class="sig-paren">(</span><em>G</em>, <em>iteration_function</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#serial_iteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.serial_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies <code class="docutils literal"><span class="pre">iteration_function</span></code> over all nodes in <code class="docutils literal"><span class="pre">G</span></code> in a <em>serial fashion</em> (i.e. one
node at a time).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> (<em>An EquibelGraph object</em>) &#8211; </li>
<li><strong>iteration_function</strong> (<em>A function that conforms to the following input/output interface:</em>) &#8211; <dl class="docutils">
<dt><strong>Input:</strong> Takes a graph <code class="docutils literal"><span class="pre">G</span></code>, a node <code class="docutils literal"><span class="pre">center</span></code> for which to compute</dt>
<dd>the results of the iteration, and a set of <code class="docutils literal"><span class="pre">atoms</span></code>.</dd>
<dt><strong>Output:</strong> Returns a singleton dictionary of the form <code class="docutils literal"><span class="pre">{</span> <span class="pre">center:</span> <span class="pre">formula</span> <span class="pre">}</span></code></dt>
<dd>mapping the node <code class="docutils literal"><span class="pre">center</span></code> to a formula resulting from the iteration.</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.simple_semantic">
<code class="descclassname">equibel.solver.</code><code class="descname">simple_semantic</code><span class="sig-paren">(</span><em>G</em>, <em>center</em>, <em>atoms</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#simple_semantic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.simple_semantic" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the formula for node <code class="docutils literal"><span class="pre">center</span></code> in graph <code class="docutils literal"><span class="pre">G</span></code> that results from
one iteration of the simple (fixed-radius) approach, using the <em>semantic characterization</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> (<em>An EquibelGraph object, representing a graph and an associated scenario</em>) &#8211; </li>
<li><strong>center</strong> (A node in <code class="docutils literal"><span class="pre">G</span></code> for which to compute the result of simple iteration) &#8211; </li>
<li><strong>atoms</strong> (A set of Sympy atomic propositions, representing the <em>alphabet</em>.) &#8211; </li>
<li><strong>opt_type</strong> (<em>A string that is either &quot;inclusion&quot; or &quot;cardinality&quot;, representing</em>) &#8211; the type of maximization to be performed over equivalences.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.simple_syntactic">
<code class="descclassname">equibel.solver.</code><code class="descname">simple_syntactic</code><span class="sig-paren">(</span><em>G</em>, <em>center</em>, <em>atoms</em>, <em>opt_type='inclusion'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#simple_syntactic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.simple_syntactic" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the formula for node <code class="docutils literal"><span class="pre">center</span></code> in graph <code class="docutils literal"><span class="pre">G</span></code> that results from
one iteration of the simple (fixed-radius) approach, using the <em>syntactic characterization</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> (<em>An EquibelGraph object, representing a graph and an associated scenario</em>) &#8211; </li>
<li><strong>center</strong> (A node in <code class="docutils literal"><span class="pre">G</span></code> for which to compute the result of simple iteration) &#8211; </li>
<li><strong>atoms</strong> (A set of Sympy atomic propositions, representing the <em>alphabet</em>.) &#8211; </li>
<li><strong>opt_type</strong> (<em>A string that is either &quot;inclusion&quot; or &quot;cardinality&quot;, representing</em>) &#8211; the type of maximization to be performed over equivalences.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equibel.solver.simplify_all_formulas">
<code class="descclassname">equibel.solver.</code><code class="descname">simplify_all_formulas</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/equibel/solver.html#simplify_all_formulas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#equibel.solver.simplify_all_formulas" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies the formulas of all nodes in <code class="docutils literal"><span class="pre">G</span></code>.</p>
<p>This function modifies <code class="docutils literal"><span class="pre">G</span></code> in place; it does <strong>not</strong> return a new graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>G</strong> (An <code class="docutils literal"><span class="pre">EquibelGraph</span></code> object.) &#8211; </td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;p &amp; (p | q | r | s)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;(p &amp; q) | (p &amp; ~q)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eb</span><span class="o">.</span><span class="n">simplify_all_formulas</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">formulas</span><span class="p">()</span>
<span class="go">{0: set([p]), 1: set([p])}</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-equibel">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-equibel" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="equibel.asp.html" class="btn btn-neutral float-right" title="equibel.asp package" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="modules.html" class="btn btn-neutral" title="equibel" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Paul Vicol.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'a1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>