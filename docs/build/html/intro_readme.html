

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Currently Supported Platforms &mdash; Equibel a1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Equibel a1 documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Equibel
          

          
          </a>

          
            
            
              <div class="version">
                0.9.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">equibel</a></li>
<li class="toctree-l1"><a class="reference internal" href="licence.html">Licence</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Equibel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Currently Supported Platforms</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/intro_readme.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>Equibel is a Python package for working with consistency-based belief change in a
graph-oriented setting.</p>
<div class="section" id="currently-supported-platforms">
<h1>Currently Supported Platforms<a class="headerlink" href="#currently-supported-platforms" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>OS X with Python 2.7.x</li>
<li>64-bit Linux with Python 2.7.x</li>
</ul>
<p>Note that while Equibel is distributed as a Python package, the core of the system is
implemented using Answer Set Programming (ASP), and relies on a nunderlying ASP solver
called <code class="docutils literal"><span class="pre">clingo</span></code>, which is part of the
<a class="reference external" href="http://potassco.sourceforge.net">Potsdam Answer Set Solving Collection (Potassco)</a>.</p>
<p>In particular, Equibel has two ASP-related dependencies: the
<a class="reference external" href="http://potassco.sourceforge.net/gringo.html">Python gringo module</a>, which provides an
interface to an ASP solver from within Python, and <code class="docutils literal"><span class="pre">asprin.parser</span></code>, which is a component of
the <code class="docutils literal"><span class="pre">asprin</span></code> preference-handling framework. <code class="docutils literal"><span class="pre">asprin</span></code> is described in more detail
<a class="reference external" href="http://www.cs.uni-potsdam.de/asprin/">here</a>, and can be download from
<a class="reference external" href="https://sourceforge.net/projects/potassco/files/asprin/">here</a>.</p>
<p>The <em>Python</em> component of Equibel is highly portable across platforms; however, the <code class="docutils literal"><span class="pre">gringo</span></code>
and <code class="docutils literal"><span class="pre">asprin.parser</span></code> dependencies must be compiled for specific system configurations, producing
system-specific binaries.
In order to simplify usage for some <em>common</em> system configurations, Equibel includes pre-compiled
binaries of these dependencies for 64-bit Linux distributions and Mac OS. These are placed in
the <code class="docutils literal"><span class="pre">equibel/includes/</span></code> directory, which is structured as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>equibel/includes/
├── __init__.py
├── linux_64
│   ├── asprin.parser
│   ├── gringo.so
│   └── __init__.py
└── mac
    ├── asprin.parser
    ├── gringo.so
    └── __init__.py
</pre></div>
</div>
<p><em>If Equibel does not function correctly once it is installed, this is likely due to the fact that the pre-compiled binaries are not compatible with your system.</em> In this case, you must compile the dependencies manually, by downloading the required components directly from
<a class="reference external" href="http://potassco.sourceforge.net">Potassco</a>, and overwriting the resulting binaries in the folder
that corresponds to your operating system.</p>
</div>
<div class="section" id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h1>
<p>The following steps assume that you have the <code class="docutils literal"><span class="pre">pip</span></code> Python package manager
installed. If you don&#8217;t have <code class="docutils literal"><span class="pre">pip</span></code>, you can get it <a class="reference external" href="https://pip.pypa.io/en/latest/installing.html">here</a>.</p>
<ol class="arabic">
<li><p class="first">The pre-compiled <code class="docutils literal"><span class="pre">gringo</span></code> modules included with Equibel for either 64-bit Linux or Mac OS require
a dependency called Threading Building Blocks (<code class="docutils literal"><span class="pre">tbb</span></code>).</p>
<blockquote>
<div><ul>
<li><p class="first">The easiest way to install the <code class="docutils literal"><span class="pre">tbb</span></code> library on <strong>Mac OS</strong> is to use [Homebrew](<a class="reference external" href="http://brew.sh">http://brew.sh</a>):</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span>$ brew install tbb
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">On <strong>Ubuntu Linux</strong>, the <code class="docutils literal"><span class="pre">tbb</span></code> library can be installed using the <code class="docutils literal"><span class="pre">apt</span></code> package manager:</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span>$ sudo apt-get install libtbb-dev
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Download the Equibel source code from <a class="reference external" href="https://github.com/asteroidhouse/equibel">Github</a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ git clone https://github.com/asteroidhouse/equibel.git
</pre></div>
</div>
<p>This will create a folder called <code class="docutils literal"><span class="pre">equibel</span></code> in your current working directory.</p>
</li>
<li><p class="first">Change directories to the <code class="docutils literal"><span class="pre">equibel</span></code> folder:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ cd equibel
</pre></div>
</div>
</li>
<li><p class="first">Install Equibel using <code class="docutils literal"><span class="pre">pip</span></code> from within the <code class="docutils literal"><span class="pre">equibel</span></code> folder as follows (note the <code class="docutils literal"><span class="pre">.</span></code> at the end):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ sudo pip install .
</pre></div>
</div>
</li>
<li><p class="first">Optionally, you can test whether everything works on your system by installing the <code class="docutils literal"><span class="pre">nose</span></code>
testing tool and running the tests in the <em>tests</em> folder, as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ sudo pip install nose
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ nosetests tests/
</pre></div>
</div>
<p>If all of the dependencies have installed correctly, the <code class="docutils literal"><span class="pre">nosetests</span> <span class="pre">tests/</span></code> should print a series
of dots to the screen, one for each successfully completed test case.</p>
<p>If the tests fail, this is most likely due to the <em>dependencies</em> of Equibel not being compatible
with your platform. As noted above, Equibel includes pre-compiled binaries of the Python <code class="docutils literal"><span class="pre">gringo</span></code>
module, as well as of <code class="docutils literal"><span class="pre">asprin.parser</span></code>, for 64-bit Linux distributions (tested on Ubuntu 14.04) and
for Mac OS (tested on OSX 10.10). If you are not using one of these systems, you will need to
manually compile the <code class="docutils literal"><span class="pre">gringo</span></code> and <code class="docutils literal"><span class="pre">asprin.parser</span></code> dependencies.</p>
</li>
</ol>
</div>
<div class="section" id="quickstart">
<h1>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h1>
<p>To use Equibel within a Python program, you need to import the <code class="docutils literal"><span class="pre">equibel</span></code>
module.
Every form of belief change in Equibel takes as input an <code class="docutils literal"><span class="pre">EquibelGraph</span></code> object
(that represents a graph and associated scenario) and outputs a new <code class="docutils literal"><span class="pre">EquibelGraph</span></code>
object. The following Python script creates a path graph, assigns formulas to nodes,
find the global completion, and prints the resulting formulas at each node:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">equibel</span> <span class="k">as</span> <span class="nn">eb</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># Create an EquibelGraph object, which represents a graph and</span>
    <span class="c1"># associated scenario.</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">EquibelGraph</span><span class="p">()</span>

    <span class="c1"># Create nodes:</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

    <span class="c1"># Create edges:</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)])</span>

    <span class="c1"># Add formulas to nodes:</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;p &amp; q &amp; r&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;~p &amp; ~q&quot;</span><span class="p">)</span>

    <span class="c1"># Find the global completion of the G-scenario:</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">global_completion</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="c1"># Pretty-prints the resulting formulas at each node:</span>
    <span class="n">eb</span><span class="o">.</span><span class="n">print_formulas</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
</pre></div>
</div>
<p>If the above code is saved in a file called <code class="docutils literal"><span class="pre">completion.py</span></code>, then it can be run by typing
<code class="docutils literal"><span class="pre">python</span> <span class="pre">completion.py</span></code> at the command line, as follows:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span>$ python completion.py
Node 1:
p ∧ q ∧ r
Node 2:
r
Node 3:
r
Node 4:
r ∧ ¬p ∧ ¬q
</pre></div>
</div>
</div>
<div class="section" id="implemented-approaches">
<h1>Implemented Approaches<a class="headerlink" href="#implemented-approaches" title="Permalink to this headline">¶</a></h1>
<p>Equibel allows for experimentation with several different approaches to
consistency-based belief change in a graph-oriented setting, namely:</p>
<ol class="arabic simple">
<li>Global completion,</li>
<li>Simple iteration,</li>
<li>Expanding iteration,</li>
<li>Augmenting iteration, and</li>
<li>The ring method.</li>
</ol>
<p>The global completion opteration is performed on an <code class="docutils literal"><span class="pre">EquibelGraph</span></code> <code class="docutils literal"><span class="pre">G</span></code> by
<code class="docutils literal"><span class="pre">eb.global_completion(G)</span></code>; this performs a &#8220;one-shot&#8221; procedure to update
the information at every node in the graph, and thus is not an iterative approach. All
of the other approaches&#8212;<em>simple</em>, <em>expanding</em>, <em>augmenting</em>, and <em>ring</em>&#8212;can be performed
iteratively, and each one iterates to a <em>fixpoint</em>. The table below summarizes the Equibel
functions to perform single iterations of each approach, as well as to find the fixpoints
reached by each approach:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="33%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Single Iteration</th>
<th class="head">Iterate to Fixpoint</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Simple Iteration</td>
<td><code class="docutils literal"><span class="pre">eb.iterate_simple(G)</span></code></td>
<td><code class="docutils literal"><span class="pre">eb.iterate_simple_fixpoint(G)</span></code></td>
</tr>
<tr class="row-odd"><td>Expanding Iteration</td>
<td><code class="docutils literal"><span class="pre">eb.iterate_expanding(G)</span></code></td>
<td><code class="docutils literal"><span class="pre">eb.iterate_expanding_fixpoint(G)</span></code></td>
</tr>
<tr class="row-even"><td>Augmenting Iteration</td>
<td><code class="docutils literal"><span class="pre">eb.iterate_augmenting(G)</span></code></td>
<td><code class="docutils literal"><span class="pre">eb.iterate_augmenting_fixpoint(G)</span></code></td>
</tr>
<tr class="row-odd"><td>Ring Iteration</td>
<td><code class="docutils literal"><span class="pre">eb.iterate_ring(G)</span></code></td>
<td><code class="docutils literal"><span class="pre">eb.iterate_ring_fixpoint(G)</span></code></td>
</tr>
</tbody>
</table>
<p>Each of the approaches has two separate implementations, corresponding to its equivalent <em>semantic</em> and
<em>syntactic</em> characterizations. In addition, there are two ways of performing the core optimization
procedure over equivalences, involving either <em>inclusion-based</em> or <em>cardinality-based</em> maximization.</p>
<p>Each function listed above can take three optional arguments:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first"><code class="docutils literal"><span class="pre">method</span></code>, which is a string that is either &#8220;semantic&#8221; or &#8220;syntactic&#8221;,
representing the method to use when performing the approach; e.g. based
on either the syntactic or semantic characterizations</p>
<blockquote>
<div><ul class="simple">
<li>The default <code class="docutils literal"><span class="pre">method</span></code> is <em>semantic</em></li>
<li>To avoid typos when entering strings, Equibel has constants <code class="docutils literal"><span class="pre">eb.SEMANTIC</span></code>
and <code class="docutils literal"><span class="pre">eb.SYNTACTIC</span></code> which equal the strings &#8220;semantic&#8221; and &#8220;syntactic&#8221;, respectively.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">opt_type</span></code>, which is a string that is either &#8220;inclusion&#8221; or &#8220;cardinality&#8221;,
representing the type of maximization to be  performed over equivalences</p>
<blockquote>
<div><ul class="simple">
<li>The default <code class="docutils literal"><span class="pre">opt_type</span></code> is <em>inclusion</em></li>
<li>To avoid typos when entering strings, Equibel has constants <code class="docutils literal"><span class="pre">eb.INCLUSION</span></code>
and <code class="docutils literal"><span class="pre">eb.CARDINALITY</span></code> which equal the strings &#8220;inclusion&#8221; and &#8220;cardinality&#8221;, respectively.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">simplify</span></code>, which is a Boolean flag specifying whether to simplify the
final formulas at each node.</p>
<blockquote>
<div><ul class="simple">
<li>The default value for <code class="docutils literal"><span class="pre">simplify</span></code> is <code class="docutils literal"><span class="pre">False</span></code></li>
</ul>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p>By definition, the semantic and syntactic characterizations of an approach yield
<em>equivalent results</em>; however, depending on the input scenario and type of approach, the
performance of the characterizations may differ significantly. A good example of this is
in the case of expanding iteration, where we have an <em>early-stoppping condition</em> over the
radius of the expanding neighbourhood when using the semantic characterization, but not when
using the syntactic characterization (causing the semantic characterization to be significantly
faster for large graphs in practice).</p>
<div class="section" id="some-examples">
<h2>Some Examples<a class="headerlink" href="#some-examples" title="Permalink to this headline">¶</a></h2>
<p>To show how the <code class="docutils literal"><span class="pre">method</span></code> and <code class="docutils literal"><span class="pre">opt_type</span></code> arguments can be combined, we consider the following
(by no means exhausitive) examples.</p>
<p>In the following example, we can see the difference between using inclusion-based optimization and
cardinality-based optimization in the global completion:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">equibel</span> <span class="k">as</span> <span class="nn">eb</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="c1"># Creates a star graph with nodes [0, 1, 2, 3] and undirected edges [(0,1), (0,2), (0,3)]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">star_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_formula</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;~p&#39;</span><span class="p">)</span>

    <span class="c1"># Using inclusion-based maximization over equivalences</span>
    <span class="n">R_inclusion</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">global_completion</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">eb</span><span class="o">.</span><span class="n">SEMANTIC</span><span class="p">,</span> <span class="n">opt_type</span><span class="o">=</span><span class="n">eb</span><span class="o">.</span><span class="n">INCLUSION</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">eb</span><span class="o">.</span><span class="n">print_formulas</span><span class="p">(</span><span class="n">R_inclusion</span><span class="p">)</span>

    <span class="c1"># Using cardinality-based maximization over equivalences</span>
    <span class="n">R_cardinality</span> <span class="o">=</span> <span class="n">eb</span><span class="o">.</span><span class="n">global_completion</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">eb</span><span class="o">.</span><span class="n">SEMANTIC</span><span class="p">,</span> <span class="n">opt_type</span><span class="o">=</span><span class="n">eb</span><span class="o">.</span><span class="n">CARDINALITY</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">eb</span><span class="o">.</span><span class="n">print_formulas</span><span class="p">(</span><span class="n">R_cardinality</span><span class="p">)</span>
</pre></div>
</div>
<p>Saving this code in a file <code class="docutils literal"><span class="pre">inclusion_vs_cardinality.py</span></code> and running it yields:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span>$ python inclusion_vs_cardinality.py
Node 0:
p ∨ ¬p
Node 1:
p
Node 2:
p
Node 3:
¬p


Node 0:
p
Node 1:
p
Node 2:
p
Node 3:
¬p
</pre></div>
</div>
<p>The following example function calls show the flexible way in which options can be combined and
used with any approach in Equibel:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">R_semantic</span> <span class="pre">=</span> <span class="pre">eb.global_completion(G)</span></code></dt>
<dd><ul class="first last simple">
<li>This function call computes the global completion of <code class="docutils literal"><span class="pre">G</span></code>.
With no options explicitly specified, the defaults are used; thus,
this call involves the <em>semantic characterization</em> with <em>inclusion-based</em> optimization,
and does not simplify the resultant formulas.</li>
<li>With all options explicitly specified, the above function call is equivalent to
<code class="docutils literal"><span class="pre">R_semantic</span> <span class="pre">=</span> <span class="pre">eb.global_completion(G,</span> <span class="pre">method=eb.SEMANTIC,</span> <span class="pre">opt_type=eb.INCLUSION,</span> <span class="pre">simplify=False)</span></code></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">R_semantic</span> <span class="pre">=</span> <span class="pre">eb.global_completion(G,</span> <span class="pre">method=eb.SYNTACTIC)</span></code></dt>
<dd><ul class="first last simple">
<li>This call finds the global completion of <code class="docutils literal"><span class="pre">G</span></code>, using the <em>syntactic characterization</em>,
the default <em>inclusion-based</em> optimization, and no simplification of formulas.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">R_semantic</span> <span class="pre">=</span> <span class="pre">eb.global_completion(G,</span> <span class="pre">method=eb.SYNTACTIC,</span> <span class="pre">opt_type=CARDINALITY)</span></code></dt>
<dd><ul class="first last simple">
<li>This call finds the global completion of <code class="docutils literal"><span class="pre">G</span></code>, using the <em>syntactic characterization</em>,
<em>cardinality-based</em> optimization, and no simplification of formulas.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">R_semantic</span> <span class="pre">=</span> <span class="pre">eb.iterate_simple(G,</span> <span class="pre">method=eb.SEMANTIC,</span> <span class="pre">simplify=True)</span></code></dt>
<dd><ul class="first last simple">
<li>This function call computes the graph and scenario that result from performing a single
<em>simple iteration</em> over <code class="docutils literal"><span class="pre">G</span></code>, using the <em>semantic characterization</em> with default
<em>inclusion-based</em> optimization. With the <code class="docutils literal"><span class="pre">simplify=True</span></code> option, the resulting scenario
will have simplified formulas for each node in the graph.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">R_syntactic</span> <span class="pre">=</span> <span class="pre">eb.iterate_simple(G,</span> <span class="pre">method=eb.SYNTACTIC,</span> <span class="pre">simplify=True)</span></code></dt>
<dd><ul class="first last simple">
<li>This call is similar to the previous call, except that it uses the <em>syntactic characterization</em>
of simple iteration, rather than the semantic characterization.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">R_semantic_fixpoint</span> <span class="pre">=</span> <span class="pre">eb.iterate_simple_fixpoint(G,</span> <span class="pre">method=eb.SEMANTIC,</span> <span class="pre">opt_type=eb.CARDINALITY,</span> <span class="pre">simplify=True)</span></code></dt>
<dd><ul class="first last simple">
<li>This computes the fixpoint reached by a sequence of <em>simple iterations</em> starting from the
graph and scenario represented by <code class="docutils literal"><span class="pre">G</span></code>, using the <em>semantic characterization</em> and
<em>cardinality-based</em> optimization.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">R_semantic</span> <span class="pre">=</span> <span class="pre">eb.iterate_expanding(G,</span> <span class="pre">simplify=True)</span></code></dt>
<dd><ul class="first last simple">
<li>This function call computes the graph and scenario that result from performing a single
<em>expanding iteration</em> over <code class="docutils literal"><span class="pre">G</span></code>, using the default <em>semantic characterization</em> with default
<em>inclusion-based</em> optimization. Since <code class="docutils literal"><span class="pre">simplify=True</span></code>, the resulting scenario
will have simplified formulas for each node in the graph.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">R_semantic</span> <span class="pre">=</span> <span class="pre">eb.iterate_augmenting_fixpoint(G,</span> <span class="pre">simplify=True)</span></code></dt>
<dd><ul class="first last simple">
<li>This computes the fixpoint reached by a sequence of <em>augmenting iterations</em> starting from the
graph and scenario represented by <code class="docutils literal"><span class="pre">G</span></code>, using the default <em>semantic characterization</em>
and <em>inclusion-based</em> optimization. Since <code class="docutils literal"><span class="pre">simplify=True</span></code>, the resulting scenario
will have simplified formulas for each node in the graph.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Paul Vicol.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'a1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>